%% Dynamical Systems Models

clear; IntializeNotebook(Quiet=true);
%% Styles

% Styles relevant for the notebook (live script) itself; not
% relevant for actual plots, so not essential
% SetStyles();

% Next styles used in plots, so useful even in standard scripts
% Define these as globals so that local functions can reference
% them if needed.

global FontName;
FontName   = "Arial"; % "Lucida Sans OT"

global C4Color C12Color MixedColor LasBColor LasIColor RhlIColor;
C4Color    = [237,176,129]/255;
C12Color   = [193,65,104]/255;
MixedColor = [229,113,94]/255;
LasBColor  = [44,49,114]/255;
LasIColor  = [165,205,144]/255;
RhlIColor  = [52,133,141]/255;

% Custom color maps
global crest flare;
load("crest.mat");
load("flare.mat");
%% Setup

% Retrieve model parameter estimates. Since these values are
% used throughout the notebook, they're stored as global data
% to avoid Workspace clutter and verbose function signatures.

LoadModel();
% global Model; % uncomment this line to expose model to workspace
%% Parameterize Dynamic Model

% In order to fully parameterize the dynamic model of Equation 3, we
% must estimate the proportionality constants that scale synthase
% expresssion level to per-capita signal production. Observations
% referenced in text provide data for those estimates.
% Get Observational Data

DensitySignalFile = "../Raw Data/ds5721-AHL-finalpredicted.csv";
% We don't need the entire contents of the file, so parse it to detect
% the options available and only retrieve the information we need.
DensitySignalOptions = detectImportOptions(DensitySignalFile);
% Get only the columns we need.
DensitySignalOptions.SelectedVariableNames = ["signal", "uM", "density"];
DensitySignalData = readtable(DensitySignalFile, DensitySignalOptions);
% Separate C4 and C12 data.
DensityC4Data = DensitySignalData(DensitySignalData.signal == "C4", :);
DensityC12Data = DensitySignalData(DensitySignalData.signal == "C12", :);
% Estimate Proportionality Constants

% Use non-linear least squares to estimate the constants

LSQFn = @(c_d2) DensitySignalObjectiveFn( ...
    c_d2 = c_d2, ...
    Data = DensitySignalData, ...
    mean_C12 = mean(DensityC12Data.uM), ...
    mean_C4 = mean(DensityC4Data.uM) ...
);
c_d2 = lsqnonlin( ...
    LSQFn, ...               % Objective function to minimize
    [0.00002, 0.00002], ...  % Starting guess for constants
    [0 0], ...               % Lower bounds for constants
    [Inf Inf], ...           % Upper bounds for constants
    optimoptions('lsqnonlin', Display = "off") ...  % No logging
);

% Predict Concentrations

ODmin = 0;
ODmax = max(0.8, 1.1 * max(DensitySignalData.density));
ODrange = ODmin : (ODmax - ODmin) / 100 : ODmax;
S1 = []; S2 = []; LasB = [];
for OD = ODrange
    Sstar = Equilibrium(N = OD, m_d2 = 0, c_d2 = c_d2);
    S1(end + 1) = Sstar(1); %#ok<SAGROW>
    S2(end + 1) = Sstar(2); %#ok<SAGROW>
    % Also estimate LasB while we're iterating through the range
    LasB(end + 1) = LasBExp(C12 = Sstar(1), C4 = Sstar(2)); %#ok<SAGROW>
end

% Compare Predictions and Observations

PlotConstants = plot( ...
    DensityC12Data.density, DensityC12Data.uM, "o", ...
    DensityC4Data.density, DensityC4Data.uM, "o", ...
    ODrange, S1, ":", ...
    ODrange, S2, ":", ...
    LineWidth = 2 ...
);
PlotConstants(1).Color = C12Color;
PlotConstants(2).Color = C4Color;
PlotConstants(3).Color = C12Color;
PlotConstants(4).Color = C4Color;
ax = gca;
ax.FontName = FontName;
xlabel("Population Density (~ OD600)", FontName=FontName, FontSize=14); 
xtickformat('%.1f')
ylabel("Concentration (μM)", FontName=FontName, FontSize=14);
title("Equilibrium Signal Concentration", FontName=FontName, FontSize=16);
legend(["3–oxo–C_{12}–HSL", "C_{4}-HSL", "", ""], FontName=FontName, FontSize=14, Location='northwest');
exportgraphics(ax, "../Prefigures/constants.pdf", 'ContentType', 'vector');
%% Calculate Model Response

% Now that the dynamic model is fully parameterized, explore its
% behavior under different conditions of population density and
% mass transfer. We consider a total of five different cases.
% For hierarhical and independent architectures, scaled and
% unscaled versions are options.

Architectures = {
    {"reciprocal",   false}, ...
    {"hierarchical", false}, ...
    {"hierarchical", true},  ...
    {"independent",  false}, ...
    {"independent",  true}
};

Columns = [
    ["Architecture", "string"]; ...
    ["Scaled",       "logical"]; ... 
    ["Density",      "double"]; ... 
    ["MassTransfer", "double"]; ...
    ["C12",          "double"]; ...
    ["C4",           "double"]; ...
    ["lasB",         "double"] ...
];

% Varying Population Density
Nrange = 0 : 0.005 : 1.0;

% Varying Mass Transfer
Mrange = 0 : 0.025 : 5.0;

NMtable = table( ...
    'Size', [length(Architectures) * length(Mrange) * length(Nrange), height(Columns)], ...
    'VariableNames', Columns(:,1), ...
    'VariableTypes', Columns(:,2) ...
);

idx = 1;
for idxArch = 1 : length(Architectures)
    Architecture = Architectures{idxArch}{1};
    Scale = Architectures{idxArch}{2};
    for N = Nrange
        S0 = [1, 1];
        for M = Mrange
            Sstar = Equilibrium(N = N, m_d2 = M, c_d2 = c_d2, Architecture = Architecture, Scale = Scale, S0 = S0);
            lasB = LasBExp(C12 = Sstar(1), C4 = Sstar(2));
            NMtable.Architecture(idx) = Architecture;
            NMtable.Scaled(idx) = Scale;
            NMtable.Density(idx) = N;
            NMtable.MassTransfer(idx) = M;
            NMtable.C12(idx) = Sstar(1);
            NMtable.C4(idx) = Sstar(2);
            NMtable.lasB(idx) = lasB;
            idx = idx + 1;
            S0 = Sstar;
        end
    end
end
%% _lasB_ Expression

% Check model fit vs. data

% Data from Rattray et al. 2022 (see text)
AggregateDataFile = "../Raw Data/Rattray.csv";
% We don't need the entire contents of the file, so parse it to detect
% the options available and only retrieve the information we need.
AggregateDataOptions = detectImportOptions(AggregateDataFile);
% Get only the columns we need.
AggregateDataOptions.SelectedVariableNames = ["od", "mean_expression"];
AggregateDataOptions.MissingRule = 'omitrow';
AggregateDataOptions.ImportErrorRule = 'omitrow';
AggregateData = readtable(AggregateDataFile, AggregateDataOptions);

% Calculate model estimate of lasB expression for measured densities
for i = 1: height(AggregateData)
    Sstar = Equilibrium(N = AggregateData.od(i), m_d2 = 0, c_d2 = c_d2);
    AggregateData.model(i) = LasBExp(C12 = Sstar(1), C4 = Sstar(2));
end

% Linear regression to map observed pixel intensity to estimated expression.
X = [ones(length(AggregateData.mean_expression), 1) AggregateData.mean_expression];
Y = AggregateData.model;
b = X \ Y;
Ypredict = X * b;

% Calculate (and show) coefficient of determination
R2 = 1 - sum((Y - Ypredict).^2)/sum((Y - mean(Y)).^2)

Xrange = [1 1; 2.25 13.25];
Yrange = Xrange' * b;

LasB_Response = figure;
LasB_Response.Position(4) = 2 * LasB_Response.Position(4);
tiledlayout(4,3);
nexttile([2, 3]);

yyaxis left
plot(ODrange, LasB, LineWidth = 3, Color = LasBColor);
ax = gca;
ax.FontName = FontName;
ax.YColor = [0 0 0];
xlabel("Population Density (~ OD600)", FontName=FontName, FontSize=14);
xtickformat('%.1f')
ylabel("Predicted Per-Capita Expression (RLU/OD)", FontName=FontName, FontSize=14);
ylim(Yrange);

yyaxis right
scatter(AggregateData.od, AggregateData.mean_expression, 50, RhlIColor, LineWidth=2);
ylabel("Observed Per-Capita Response (Pixel Intensity)", FontName=FontName, FontSize=14);
ax = gca;
ax.FontName = FontName;
ax.YColor = [0 0 0];
ylim(Xrange(2,:));
title("\it lasB\rm Expression", FontName=FontName, FontWeight="normal", FontSize=16);
legend({"Model", "Observations"}, FontName=FontName, FontSize=14, Location='northwest');
text(-0.1, 1.05, "A", FontName=FontName, FontSize=16, FontWeight="normal", Units="normalized");

% Extract values of interest as NxM matrix so they can be treated
% as a pixel image. Note that the data must be sorted appropriately
% so that the image is in row-major order with respect to mass
% transfer. That means mass-transfer will be the x-axis of the
% image. Also note that density is sorted in descending order
% so that higher density values are first, e.g. the "top" of
% the image and in their natural position for a y-axis.

getMatrix = @(prop, architecture, scaled) reshape( ...
    sortrows( ...
        NMtable(NMtable.Architecture == architecture & NMtable.Scaled == scaled, :), ...
        {'MassTransfer', 'Density'}, {'ascend', 'descend'} ...
    ).(prop), ...
    length(Nrange), ...
    length(Mrange) ...
);

% Use the same range for all heatmaps so that they can be compared 
% against each other easily. It's the max and min values from
% the reciprocal architcture

LasBValues = NMtable(NMtable.Architecture == "reciprocal", :).lasB;
LasBRange=[min(LasBValues), max(LasBValues)];

% Generate native heatmap to check results below. This heatmap isn't used
% in paper since low level functions provide better control over axes,
% etc., but it can be helpful to verify low level results, especially
% plot orientation. Note that MATLAB orients heatmaps so that rows are
% shown in descending order, so the y-axis will be flipped.

%figure
%heatmap(NMtable(NMtable.Architecture == "reciprocal", :), ...
%    "MassTransfer", "Density", ColorVariable="lasB", ...
%    GridVisible="off", Colormap=flare);

% Create the final heatmaps - unscaled versions first


AxisReciprocal = nexttile;
MakeHeatmap( ...
    dataMatrix=getMatrix('lasB', "reciprocal", false), ...
    dataRange=LasBRange, ...
    xRange=Mrange, ...
    yRange=Nrange, ...
    thresholds = [0.05, 0.5], ...
    plotTitle="Reciprocal", ...
    plotSubtitle="B", ...
    xLabel="Mass Transfer Rate", ...
    yLabel="Population Density (~ OD600)", ...
    legendLabel="" ...
);
AxisHierarchical = nexttile;
MakeHeatmap( ...
    dataMatrix=getMatrix('lasB', "hierarchical", false), ...
    dataRange=LasBRange, ...
    xRange=Mrange, ...
    yRange=Nrange, ...
    thresholds = [0.05, 0.5], ...
    plotTitle="Hierarchical", ...
    plotSubtitle="C", ...
    xLabel={'Mass Transfer Rate', '(Normalized to C_{4}-HSL Decay Rate)'}, ...
    yLabel="", ...
    legendLabel="" ...
);
AxisIndependent = nexttile;
MakeHeatmap( ...
    dataMatrix=getMatrix('lasB', "independent", false), ...
    dataRange=LasBRange, ...
    xRange=Mrange, ...
    yRange=Nrange, ...
    thresholds = [0.05, 0.5], ...
    plotTitle="Independent", ...
    plotSubtitle="D", ...
    xLabel="Mass Transfer Rate", ...
    yLabel="", ...
    legendLabel="\it lasB\rm\rm (RLU/OD)" ...
);
AxisReciprocalScaled = nexttile;
MakeHeatmap( ...
    dataMatrix=getMatrix('lasB', "reciprocal", false), ...
    dataRange=LasBRange, ...
    xRange=Mrange, ...
    yRange=Nrange, ...
    thresholds = [0.05, 0.5], ...
    plotTitle="Reciprocal", ...
    plotSubtitle="E", ...
    xLabel="Mass Transfer Rate", ...
    yLabel="Population Density (~ OD600)", ...
    legendLabel="" ...
);
AxisHierarchicalScaled = nexttile;
MakeHeatmap( ...
    dataMatrix=getMatrix('lasB', "hierarchical", true), ...
    dataRange=LasBRange, ...
    xRange=Mrange, ...
    yRange=Nrange, ...
    thresholds = [0.05, 0.5], ...
    plotTitle="Rescaled Hierarchical", ...
    plotSubtitle="F", ...
    xLabel={'Mass Transfer Rate', '(Normalized to C_{4}-HSL Decay Rate)'}, ...
    yLabel="", ...
    legendLabel="" ...
);
AxisIndepedentScaled = nexttile;
MakeHeatmap( ...
    dataMatrix=getMatrix('lasB', "independent", true), ...
    dataRange=LasBRange, ...
    xRange=Mrange, ...
    yRange=Nrange, ...
    thresholds = [0.05, 0.5], ...
    plotTitle="Rescaled Independent", ...
    plotSubtitle="G", ...
    xLabel="Mass Transfer Rate", ...
    yLabel="", ...
    legendLabel="\it lasB\rm\rm (RLU/OD)" ...
);

colormap(AxisReciprocal, flare);
colormap(AxisHierarchical, flare);
colormap(AxisIndependent, flare);
colormap(AxisReciprocalScaled, crest);
colormap(AxisHierarchicalScaled, crest);
colormap(AxisIndepedentScaled, crest);
exportgraphics(LasB_Response, "../Prefigures/lasb_response.pdf", 'ContentType', 'vector');
% Signal Concentration

C4Values = NMtable(NMtable.Architecture == "reciprocal", :).C4;
C4Range=[min(C4Values), max(C4Values)];
C12Values = NMtable(NMtable.Architecture == "reciprocal", :).C12;
C12Range=[min(C12Values), max(C12Values)];

SignalHeatmaps = figure;
colormap(flare);

tiledlayout(2,3);
nexttile;
MakeHeatmap( ...
    dataMatrix=getMatrix('C12', "reciprocal", false), ...
    dataRange=C12Range, ...
    xRange=Mrange, ...
    yRange=Nrange, ...
    plotTitle="Reciprocal", ...
    plotSubtitle="A", ...
    xLabel="", ...
    yLabel="Population Density (~ OD600)", ...
    thresholds = [0.05, 0.5], ...
    legendLabel="", ...
    xTicks={'0', '2', '4'} ...
);
nexttile;
MakeHeatmap( ...
    dataMatrix=getMatrix('C12', "hierarchical", false), ...
    dataRange=C12Range, ...
    xRange=Mrange, ...
    yRange=Nrange, ...
    plotTitle="Hierarchical", ...
    plotSubtitle="B", ...
    xLabel="", ...
    yLabel="", ...
    thresholds = [0.05, 0.5], ...
    legendLabel="", ...
    xTicks={'0', '2', '4'} ...
);
nexttile;
MakeHeatmap( ...
    dataMatrix=getMatrix('C12', "independent", false), ...
    dataRange=C12Range, ...
    xRange=Mrange, ...
    yRange=Nrange, ...
    plotTitle="Independent", ...
    plotSubtitle="C", ...
    xLabel="", ...
    yLabel="", ...
    thresholds = [0.05, 0.5], ...
    legendLabel="3–oxo–C_{12}–HSL (μM)", ...
    xTicks={'0', '2', '4'} ...
);

nexttile;
MakeHeatmap( ...
    dataMatrix=getMatrix('C4', "reciprocal", false), ...
    dataRange=C4Range, ...
    xRange=Mrange, ...
    yRange=Nrange, ...
    plotTitle="", ...
    plotSubtitle="D", ...
    xLabel="", ...
    yLabel="Population Density (~ OD600)", ...
    thresholds = [0.05, 0.5], ...
    legendLabel="", ...
    xTicks={'0', '2', '4'} ...
);
nexttile;
MakeHeatmap( ...
    dataMatrix=getMatrix('C4', "hierarchical", false), ...
    dataRange=C4Range, ...
    xRange=Mrange, ...
    yRange=Nrange, ...
    plotTitle="", ...
    plotSubtitle="E", ...
    xLabel="Mass Transfer Rate (Normalized to C_{4}-HSL Decay Rate)", ...
    yLabel="", ...
    thresholds = [0.05, 0.5], ...
    legendLabel="", ...
    xTicks={'0', '2', '4'} ...
);
nexttile;
MakeHeatmap( ...
    dataMatrix=getMatrix('C4', "independent", false), ...
    dataRange=C4Range, ...
    xRange=Mrange, ...
    yRange=Nrange, ...
    plotTitle="", ...
    plotSubtitle="F", ...
    xLabel="", ...
    yLabel="", ...
    thresholds = [0.05, 0.5], ...
    legendLabel="C_{4}-HSL (μM)", ...
    xTicks={'0', '2', '4'} ...
);

getRatioMatrix = @(architecture, scale) ...
    (getMatrix('C12', architecture, scale) ./ getMatrix('C4', architecture, scale));

trimLastRow = @(M) M(1:end-1,:);
trimLastCol = @(M) M(:,1:end-1);

RatioR = trimLastCol(trimLastRow(getRatioMatrix("reciprocal", false)));
RatioH = trimLastCol(trimLastRow(getRatioMatrix("hierarchical", false)));
RatioI = trimLastCol(trimLastRow(getRatioMatrix("independent", false)));
RatioRange = [ ...
    min([min(RatioR, [], "all"), min(RatioH, [], "all"), min(RatioI, [], "all")]), ...
    max([max(RatioR, [], "all"), max(RatioH, [], "all"), max(RatioI, [], "all")]) ...
];

% nexttile;
% MakeHeatmap( ...
%     dataMatrix=RatioR, ...
%     dataRange=RatioRange, ...
%     xRange=Mrange(1:end-1), ...
%     yRange=Nrange(2:end), ...
%     plotTitle="", ...
%     xLabel="", ...
%     yLabel="", ...
%     legendLabel="", ...
%     contourLevels=10, ...
%     xTicks={'0', '2', '4'} ...
% );
% 
% nexttile;
% MakeHeatmap( ...
%     dataMatrix=RatioH, ...
%     dataRange=RatioRange, ...
%     xRange=Mrange(1:end-1), ...
%     yRange=Nrange(2:end), ...
%     plotTitle="", ...
%     xLabel="Mass Transfer Rate (Normalized to C_{4}-HSL Decay Rate)", ...
%     yLabel="", ...
%     legendLabel="", ...
%     contourLevels=10, ...
%     xTicks={'0', '2', '4'} ...
% );
% 
% nexttile;
% MakeHeatmap( ...
%     dataMatrix=RatioI, ...
%     dataRange=RatioRange, ...
%     xRange=Mrange(1:end-1), ...
%     yRange=Nrange(2:end), ...
%     plotTitle="", ...
%     xLabel="", ...
%     yLabel="", ...
%     legendLabel="[C12] / [C4]", ...
%     contourLevels=10, ...
%     xTicks={'0', '2', '4'} ...
% );

exportgraphics(SignalHeatmaps, "../Prefigures/signals_heatmaps.pdf", 'ContentType', 'vector');
% Signal Ratio

SignalRatio = figure;
colormap(flare);

RatioRRange = [min(RatioR, [], "all"), max(RatioR, [], "all")];
RatioRRange(2) / RatioRRange(1)

[Heatmap, Colorbar] = MakeHeatmap( ...
    dataMatrix=RatioR, ...
    dataRange=RatioRRange, ...
    xRange=Mrange(1:end-1), ...
    yRange=Nrange(2:end), ...
    plotTitle={'Reciprocal Architecture Signal Ratio', '[3–oxo–C_{12}–HSL] / [C_{4}-HSL]'}, ...
    xLabel={'Mass Transfer Rate', '(Normalized to C_{4}-HSL Decay Rate)'}, ...
    yLabel="Population Density (~ OD600)", ...
    legendLabel=" ", ...
    contourLevels=10, ...
    xTicks={'0', '1', '2', '3', '4', '5'} ...
);
SignalRatio.CurrentAxes.FontSize = 12;
SignalRatio.CurrentAxes.Title.FontSize = 14;
Colorbar.Label.FontSize = 12;
exportgraphics(SignalRatio, "../Prefigures/signal_ratio.pdf", 'ContentType', 'vector');
%%
C4Values = NMtable(NMtable.Architecture == "independent", :).C4;
C4Range=[min(C4Values), max(C4Values)];
C12Values = NMtable(NMtable.Architecture == "independent", :).C12;
C12Range=[min(C12Values), max(C12Values)];

ScaledSignalHeatmaps = figure;
colormap(crest);

tiledlayout(2,3);
nexttile;
MakeHeatmap( ...
    dataMatrix=getMatrix('C12', "reciprocal", false), ...
    dataRange=C12Range, ...
    xRange=Mrange, ...
    yRange=Nrange, ...
    plotTitle="Reciprocal", ...
    plotSubtitle="A", ...
    xLabel="", ...
    yLabel="Population Density (~ OD600)", ...
    thresholds = [0.05, 0.5], ...
    legendLabel="", ...
    xTicks={'0', '2', '4'} ...
);
nexttile;
MakeHeatmap( ...
    dataMatrix=getMatrix('C12', "hierarchical", true), ...
    dataRange=C12Range, ...
    xRange=Mrange, ...
    yRange=Nrange, ...
    plotTitle={'Rescaled', 'Hierarchical'}, ...
    plotSubtitle="B", ...
    xLabel="", ...
    yLabel="", ...
    thresholds = [0.05, 0.5], ...
    legendLabel="", ...
    xTicks={'0', '2', '4'} ...
);
nexttile;
MakeHeatmap( ...
    dataMatrix=getMatrix('C12', "independent", true), ...
    dataRange=C12Range, ...
    xRange=Mrange, ...
    yRange=Nrange, ...
    plotTitle={'Rescaled', 'Independent'}, ...
    plotSubtitle="C", ...
    xLabel="", ...
    yLabel="", ...
    thresholds = [0.05, 0.5], ...
    legendLabel="3–oxo–C_{12}–HSL (μM)", ...
    xTicks={'0', '2', '4'} ...
);

nexttile;
MakeHeatmap( ...
    dataMatrix=getMatrix('C4', "reciprocal", false), ...
    dataRange=C4Range, ...
    xRange=Mrange, ...
    yRange=Nrange, ...
    plotTitle="", ...
    plotSubtitle="D", ...
    xLabel="", ...
    yLabel="Population Density (~ OD600)", ...
    thresholds = [0.05, 0.5], ...
    legendLabel="", ...
    xTicks={'0', '2', '4'} ...
);
nexttile;
MakeHeatmap( ...
    dataMatrix=getMatrix('C4', "hierarchical", true), ...
    dataRange=C4Range, ...
    xRange=Mrange, ...
    yRange=Nrange, ...
    plotTitle="", ...
    plotSubtitle="E", ...
    xLabel="Mass Transfer Rate (Normalized to C_{4}-HSL Decay Rate)", ...
    yLabel="", ...
    thresholds = [0.05, 0.5], ...
    legendLabel="", ...
    xTicks={'0', '2', '4'} ...
);
nexttile;
MakeHeatmap( ...
    dataMatrix=getMatrix('C4', "independent", true), ...
    dataRange=C4Range, ...
    xRange=Mrange, ...
    yRange=Nrange, ...
    plotTitle="", ...
    plotSubtitle="F", ...
    xLabel="", ...
    yLabel="", ...
    thresholds = [0.05, 0.5], ...
    legendLabel="C_{4}-HSL (μM)", ...
    xTicks={'0', '2', '4'} ...
);

getScaledRatioMatrix = @(architecture, scale) ...
    (getMatrix('C12', architecture, scale) ./ getMatrix('C4', architecture, scale));

trimLastRow = @(M) M(1:end-1,:);
trimLastCol = @(M) M(:,1:end-1);

ScaledRatioR = trimLastCol(trimLastRow(getScaledRatioMatrix("reciprocal", false)));
ScaledRatioH = trimLastCol(trimLastRow(getScaledRatioMatrix("hierarchical", true)));
ScaledRatioI = trimLastCol(trimLastRow(getScaledRatioMatrix("independent", true)));
ScaledRatioRange = [ ...
    min([min(ScaledRatioR, [], "all"), min(ScaledRatioH, [], "all"), min(ScaledRatioI, [], "all")]), ...
    max([max(ScaledRatioR, [], "all"), max(ScaledRatioH, [], "all"), max(ScaledRatioI, [], "all")]) ...
];

% nexttile;
% MakeHeatmap( ...
%     dataMatrix=RatioR, ...
%     dataRange=RatioRange, ...
%     xRange=Mrange(1:end-1), ...
%     yRange=Nrange(2:end), ...
%     plotTitle="", ...
%     xLabel="", ...
%     yLabel="", ...
%     legendLabel="", ...
%     contourLevels=10, ...
%     xTicks={'0', '2', '4'} ...
% );
% 
% 
% nexttile;
% MakeHeatmap( ...
%     dataMatrix=RatioH, ...
%     dataRange=RatioRange, ...
%     xRange=Mrange(1:end-1), ...
%     yRange=Nrange(2:end), ...
%     plotTitle="", ...
%     xLabel="Mass Transfer Rate (Normalized to C_{4}-HSL Decay Rate)", ...
%     yLabel="", ...
%     legendLabel="", ...
%     contourLevels=10, ...
%     xTicks={'0', '2', '4'} ...
% );
% 
% nexttile;
% MakeHeatmap( ...
%     dataMatrix=RatioI, ...
%     dataRange=RatioRange, ...
%     xRange=Mrange(1:end-1), ...
%     yRange=Nrange(2:end), ...
%     plotTitle="", ...
%     xLabel="", ...
%     yLabel="", ...
%     legendLabel="[C12] / [C4]", ...
%     contourLevels=10, ...
%     xTicks={'0', '2', '4'} ...
% );

exportgraphics(ScaledSignalHeatmaps, "../Prefigures/signals_scaled_heatmaps.pdf", 'ContentType', 'vector');
% Combinatorial Dynamics

% The effect of different architectures on combinatorial QS
% is easier to see in a different parameter space.

% Varying Population Density
N2range = 2 * Nrange;

% Varying Mass Transfer
M2range = 0 : 0.01 : 2.0;

NM2table = table( ...
    'Size', [length(Architectures) * length(Mrange) * length(Nrange), height(Columns)], ...
    'VariableNames', Columns(:,1), ...
    'VariableTypes', Columns(:,2) ...
);

idx = 1;
for idxArch = 1 : length(Architectures)
    Architecture = Architectures{idxArch}{1};
    Scale = Architectures{idxArch}{2};
    S0Init = [1, 1];
    for N = N2range
        S0 = S0Init;
        for M = M2range
            Sstar = Equilibrium(N = N, m_d2 = M, c_d2 = c_d2, Architecture = Architecture, Scale = Scale, S0 = S0);
            NM2table.Architecture(idx) = Architecture;
            NM2table.Scaled(idx) = Scale;
            NM2table.Density(idx) = N;
            NM2table.MassTransfer(idx) = M;
            NM2table.C12(idx) = Sstar(1);
            NM2table.C4(idx) = Sstar(2);
            idx = idx + 1;
            S0 = Sstar;
            if (M == 0)
                S0Init = Sstar;
            end
        end
    end
end

%%
getMatrix2 = @(prop, architecture, scaled) reshape( ...
    sortrows( ...
        NM2table(NM2table.Architecture == architecture & NM2table.Scaled == scaled, :), ...
        {'MassTransfer', 'Density'}, {'ascend', 'descend'} ...
    ).(prop), ...
    length(N2range), ...
    length(M2range) ...
);

Fraction = 0.33;

Combinatorial = figure;
tiledlayout(1, 3);
nexttile;
MakeCombinatorialPlot( ...
    Xrange=M2range, ...
    Yrange=N2range, ...
    C12=getMatrix2('C12', "reciprocal", false), ...
    C4=getMatrix2('C4', "reciprocal", false), ...
    fraction=Fraction, ...
    plotTitle="Reciprocal", ...
    plotSubtitle="A", ...
    xLabel="", ...
    yLabel={'Population Density', '(~ OD600)'}, ...
    legendLabel="" ...
);

nexttile;
MakeCombinatorialPlot( ...
    Xrange=M2range, ...
    Yrange=N2range, ...
    C12=getMatrix2('C12', "hierarchical", false), ...
    C4=getMatrix2('C4', "hierarchical", false), ...
    fraction=Fraction, ...
    plotTitle="Hierarchical", ...
    plotSubtitle="B", ...
    xLabel="Mass Transfer Rate (Normalized to C_{4}-HSL Decay Rate)", ...
    yLabel="", ...
    legendLabel="" ...
);

nexttile;
MakeCombinatorialPlot( ...
    Xrange=M2range, ...
    Yrange=N2range, ...
    C12=getMatrix2('C12', "independent", false), ...
    C4=getMatrix2('C4', "independent", false), ...
    fraction=Fraction, ...
    plotTitle="Independent", ...
    plotSubtitle="C", ...
    xLabel="", ...
    yLabel="", ...
    legendLabel="33% Max. Conc." ...
);
exportgraphics(Combinatorial, "../Prefigures/combinatorial.pdf", 'ContentType', 'vector');
% Time Response

Nsam = 5; % mean(Nrange);
Msam = 0; % mean(Mrange);
tSpan = [0 1];
Sinit = [0 0];

dSr = @(t, S) dS_dt(S = S, N = Nsam, m_d2 = Msam, c_d2 = c_d2, Architecture="reciprocal", Scale=false);
dSh = @(t, S) dS_dt(S = S, N = Nsam, m_d2 = Msam, c_d2 = c_d2, Architecture="hierarchical", Scale=true);
dSi = @(t, S) dS_dt(S = S, N = Nsam, m_d2 = Msam, c_d2 = c_d2, Architecture="independent", Scale=true);

[tr, Sr] = ode45(dSr, tSpan, Sinit);
LasBr = LasBExp(C12=Sr(:,1), C4=Sr(:,2));

[th, Sh] = ode45(dSh, tSpan, Sinit);
LasBh = LasBExp(C12=Sh(:,1), C4=Sh(:,2));

[ti, Si] = ode45(dSi, tSpan, Sinit);
LasBi = LasBExp(C12=Si(:,1), C4=Si(:,2));

figure;
plot(tr, LasBr, LineWidth = 3, Color = LasBColor);
hold on;
plot(th, LasBh, LineWidth = 3, Color = RhlIColor);
plot(ti, LasBi, LineWidth = 3, Color = LasIColor);
hold off;
ax = gca;
ylabel("\it lasB\rm Expression (RLU/OD)", FontName=FontName, FontSize=14);
xlabel("Time (normalized to C_{4}-HSL decay rate)", FontName=FontName, FontSize=14);
legend({"Reciprocal", "Rescaled Hierarchical", "Rescaled Independent"}, FontName=FontName, FontSize=14, Location='southeast');
title("Time Response of\it lasB\rm\bf Expression", FontName=FontName, FontSize=16);
ax = gca;
ax.FontName = FontName;
exportgraphics(ax, "../Prefigures/lasb_time_response.pdf", 'ContentType', 'vector');
%% Local Functions

function IntializeNotebook(Options)
% InitializeNotebook() ensures that the live script notebook is in a known
% starting state. Its intent is to guarantee reproducability of the
% notebook results. Note that the `clear` command does not have full
% effect when implemented within a function. Consequently, the notebook
% should execute that command explicitly before calling this function.
%
% For documentation, this function will, by default, display version and
% platform information within the notebook.
    arguments
        Options.Quiet logical = false; % if true, don't show version info
    end

    % clear workspace elements
    clc; clf;

    % initialize environment
    rng default;  % set random number generator for reproducibility
    
    if ~Options.Quiet
        % show version/platform information
        disp(strcat("This notebook created on ", string(datetime)))
        % suppress needless warning message about product ''
        warning('off', 'MATLAB:ver:NotFound');
            ver '' % don't bother with unused toolboxes, etc.
        warning('on',  'MATLAB:ver:NotFound');
    end

end

function SetStyles() %#ok<DEFNU>
% Set styles such as fonts and colors for notebook.

    Settings = settings;
    Settings.matlab.fonts.editor.normal.Name.TemporaryValue = "Lucida Bright OT";
    Settings.matlab.fonts.editor.title.Name.TemporaryValue = "Lucida Sans OT";
    Settings.matlab.fonts.editor.heading1.Name.TemporaryValue = "Lucida Sans OT";
    Settings.matlab.fonts.editor.heading2.Name.TemporaryValue = "Lucida Sans OT";
    Settings.matlab.fonts.editor.heading3.Name.TemporaryValue = "Lucida Sans OT";
    Settings.matlab.fonts.editor.code.Name.TemporaryValue = "Lucida Console DK";
    Settings.matlab.fonts.codefont.Name.TemporaryValue = "Lucida Console DK";
end

function LoadModel()
% LoadModel() retrieves and formats model parameters
    global Model; %#ok<*GVMIS>
    global a10 a11 K11 a12 K12 a112 K112 K121;
    global a20 a21 K21 a22 K22 a212 K212 K221;
    global a30 a31 K31 a32 K32 a312 K312 K321;

    Model = readtable("../Models/Summary.csv", 'ReadRowNames', true);
    GenesRegex = regexpPattern('lasI|rhlI|lasB');
    Model.Properties.RowNames = cellfun(@(str) ...
        extract(str, GenesRegex), Model.Properties.RowNames);
    Model = fillmissing(Model, 'constant', 0);

    a10 = Model{"lasI", "a0"};
    a11 = Model{"lasI", "a_c12"};
    K11 = Model{"lasI", "K_c12"};
    a12 = Model{"lasI", "a_c4"};
    K12 = Model{"lasI", "K_c4"};
    a112 = Model{"lasI", "aQ"};
    K112 = Model{"lasI", "KQ_c12"};
    K121 = Model{"lasI", "KQ_c12"};

    a20 = Model{"rhlI", "a0"};
    a21 = Model{"rhlI", "a_c12"};
    K21 = Model{"rhlI", "K_c12"};
    a22 = Model{"rhlI", "a_c4"};
    K22 = Model{"rhlI", "K_c4"};
    a212 = Model{"rhlI", "aQ"};
    K212 = Model{"rhlI", "KQ_c12"};
    K221 = Model{"rhlI", "KQ_c12"};

    a30 = Model{"lasB", "a0"};
    a31 = Model{"lasB", "a_c12"};
    K31 = Model{"lasB", "K_c12"};
    a32 = Model{"lasB", "a_c4"};
    K32 = Model{"lasB", "K_c4"};
    a312 = Model{"lasB", "aQ"};
    K312 = Model{"lasB", "KQ_c12"};
    K321 = Model{"lasB", "KQ_c12"};
end

function RLU_OD = LasIExp(Args)
% LasIExp() estimates lasI expression level in RLU/OD
% from C4 and C12 concentrations using model parameters 
    arguments
        Args.C12 double;  % 3‑oxo‑C₁₂‑HSL concentration (μM)
        Args.C4 double;   % C₄‑HSL concentration (μM)
        Args.Architecture (1,:) char ... % QS architecture
            {mustBeMember(Args.Architecture,{'reciprocal', 'hierarchical', 'independent'})} ...
            = 'reciprocal'
        Args.Scale logical = false % Scale non-reciprocal architecture?
    end
    global a10 a11 K11 a12 K12 a112 K112 K121;

    C12 = Args.C12;
    C4 = Args.C4;

    % Avoid 0/0 errors
    C4(C4 == 0) = sqrt(realmin);
    C12(C12 == 0) = sqrt(realmin);

    if Args.Architecture == "reciprocal"
        RLU_OD = a10 + ...
            a11  * C12 ./ (K11 + C12)  + ...
            a12  * C4  ./ (K12  + C4)  + ...
            a112 * C4 .* C12 ./ ((K112 + C12) .* (K121 + C4));
    elseif ~Args.Scale % hierarchical and independent are the same for lasI
        RLU_OD = a10 + a11  * C12 ./ (K11 + C12);
    else
        RLU_OD = a10 + (a11 + a12 + a112) * C12 ./ (K11 + C12);
    end
end

function RLU_OD = RhlIExp(Args)
% RhlIExp() estimates rhlI expression level in RLU/OD
% from C4 and C12 concentrations using model parameters 
    arguments
        Args.C12 double;  % 3‑oxo‑C₁₂‑HSL concentration (μM)
        Args.C4 double;   % C₄‑HSL concentration (μM)
        Args.Architecture (1,:) char ... % QS architecture
            {mustBeMember(Args.Architecture,{'reciprocal', 'hierarchical', 'independent'})} ...
            = 'reciprocal'
        Args.Scale logical = false % Scale non-reciprocal architecture?
    end
    global a20 a21 K21 a22 K22 a212 K212 K221;

    C12 = Args.C12;
    C4 = Args.C4;

    % Avoid 0/0 errors
    C4(C4 == 0) = sqrt(realmin);
    C12(C12 == 0) = sqrt(realmin);

    % reciprocal and hierarchical are the same for rhlI
    if Args.Architecture == "reciprocal" || Args.Architecture == "hierarchical"
        RLU_OD = a20 + ...
            a21  * C12 ./ (K21 + C12)  + ...
            a22  * C4  ./ (K22  + C4)  + ...
            a212 * C4 .* C12 ./ ((K212 + C12) .* (K221 + C4));
    elseif ~Args.Scale
        RLU_OD = a20 + a22 * C4  ./ (K22  + C4);
    else
        RLU_OD = a20 + (a21 + a22 + a212) * C4  ./ (K22  + C4);
   end
end

function RLU_OD = LasBExp(Args)
% LasBExp() estimates lasI expression level in RLU/OD
% from C4 and C12 concentrations using model parameters 
    arguments
        Args.C12 double;  % 3‑oxo‑C₁₂‑HSL concentration (μM)
        Args.C4 double;   % C₄‑HSL concentration (μM)
    end
    global a30 a31 K31 a32 K32 a312 K312 K321;

    C12 = Args.C12;
    C4 = Args.C4;

    % Avoid 0/0 errors
    C4(C4 == 0) = sqrt(realmin);
    C12(C12 == 0) = sqrt(realmin);

    RLU_OD = a30 + ...
        a31  * C12 ./ (K31 + C12)  + ...
        a32  * C4  ./ (K32  + C4)  + ...
        a312 * C4 .* C12 ./ ((K312 + C12) .* (K321 + C4));
end

function Residuals = DensitySignalObjectiveFn(Args)
% DensitySignalObjective() calculates residuals for a objective function
% that predicts signal concentrations as a function of density for
% specific values of proportionality constants
    arguments
        Args.c_d2 (2, 1) double;  % [c1_d2, c2_d2] proposed parameter values
        Args.Data;                % Data table of observations
        Args.mean_C12 double;     % mean C12 concentration (for normalization)
        Args.mean_C4  double;     % mean C4 concentration (for normalization)
    end

    c_d2 = Args.c_d2;
    Data = Args.Data;
    mean_C12 = Args.mean_C12;
    mean_C4 = Args.mean_C4;

    Residuals = zeros(height(Data), 1);
    for idx = 1 : height(Data)
        Sstar = Equilibrium(N = Data.density(idx), m_d2 = 0, c_d2 = c_d2);
        if Data.signal(idx) == "C12"
            Residuals(idx, 1) = (Sstar(1) - Data.uM(idx)) / mean_C12;
        else
            Residuals(idx, 1) = (Sstar(2) - Data.uM(idx)) / mean_C4;
        end
    end
end

function Sstar = Equilibrium(Args)
% Equilibrium() returns equilibrium concentrations of signals [C12, C4]
    arguments (Input)
        Args.N double;                   % population size
        Args.m_d2 double;                % mass transfer / C4 decay rate
        Args.c_d2 (2, 1) double;         % [c1_d2, c2_d2] constants
        Args.Architecture (1,:) char ... % QS architecture
            {mustBeMember(Args.Architecture,{'reciprocal', 'hierarchical', 'independent'})} ...
            = 'reciprocal'
        Args.Scale logical = false       % Scale non-reciprocal architecture?
        Args.S0 (2, 1) double = [1, 1]   % Optional starting guess; see note below
    end

    % Note: Setting S0 to different values can help prevent the
    % optimization algorithm from converging on alternate solutions in
    % which the concentrations are negative. A possible enhancement would
    % be to use non-linear optimization instead of a fsolve so that
    % constraints can be defined, but this is simpler for now. As a
    % safety check to make sure that negative values are not returned,
    % we use output validation.
    arguments (Output)
        Sstar (2, 1) double {mustBeNonnegative}
    end

    N = Args.N;
    m_d2 = Args.m_d2;
    c_d2 = Args.c_d2;
    Architecture = Args.Architecture;
    Scale = Args.Scale;
    S0 = Args.S0; 

    SolveOptions = optimoptions('fsolve', 'Display', 'none');
    dS = @(S) dS_dt(S = S, N = N, m_d2 = m_d2, c_d2 = c_d2, Architecture = Architecture, Scale = Scale);
    Sstar = fsolve(dS, S0, SolveOptions);
end

function DeltaS_d2 = dS_dt(Args)
% dS_dt() calculates the dynamics of the system of two
% signals as the change in concentration for each signal
% over time interval of C4 decay rate.
    arguments
        Args.S (2, 1) double;      % [C12, C4] concentration
        Args.N double;             % population size
        Args.m_d2 double = 0;      % mass transfer / C4 decay rate
        Args.c_d2 (2, 1) double;   % [c1_d2, c2_d2] constants
        Args.Architecture (1,:) char ... % QS architecture
            {mustBeMember(Args.Architecture,{'reciprocal', 'hierarchical', 'independent'})} ...
            = 'reciprocal'
        Args.Scale logical = false % Scale non-reciprocal architecture?
    end

    S = Args.S;
    N = Args.N;
    m_d2 = Args.m_d2;
    c_d2 = Args.c_d2;
    Architecture = Args.Architecture;
    Scale = Args.Scale;
    LasI = LasIExp(C12=S(1), C4=S(2), Architecture=Architecture, Scale=Scale);
    RhlI = RhlIExp(C12=S(1), C4=S(2), Architecture=Architecture, Scale=Scale);

    DeltaS_d2 = [ ...
        c_d2(1) * LasI * N - S(1) * (1.7 + m_d2);
        c_d2(2) * RhlI * N - S(2) * (1.0 + m_d2)
    ];

end

function [Heatmap, Colorbar] = MakeHeatmap(Args)
% MakeHeatmap creates a heatmap from a matrix of data values
    arguments
        Args.dataMatrix (:,:) double       % 2D matrix of data to show
        Args.dataRange (1, 2) double       % extent of data values
        Args.plotTitle string              % title of plot
        Args.plotSubtitle string = ""      % subtitle (A, B, C, ...)
        Args.xRange (:, 1) double          % range of x-axis values
        Args.yRange (:, 1) double          % range of y-axis values
        Args.thresholds (1, :) double = [] % threshold values to highlight
        Args.xLabel string = ""            % x-axis label
        Args.yLabel string = ""            % y-axis label
        Args.contourLevels double = 0      % add contour lines
        Args.legendLabel string = ""       % label for legend
        Args.xTicks = {'0', '1', '2', '3', '4', '5'}
    end

    global FontName;

    dataMatrix = Args.dataMatrix;
    dataRange = Args.dataRange;
    plotTitle = Args.plotTitle;
    plotSubtitle = Args.plotSubtitle;
    xRange = Args.xRange;
    yRange = Args.yRange;
    xLabel = Args.xLabel;
    yLabel = Args.yLabel;
    legendLabel = Args.legendLabel;
    thresholds = Args.thresholds;
    contourLevels = Args.contourLevels;
    xTicks = Args.xTicks;

    % threshold levels to highlight (relative to extent of data range)
    tLevels = thresholds * (dataRange(2) - dataRange(1)) + dataRange(1);
    tColors = {'black', 'white'};
    tX = zeros(length(tLevels), 2);
    tY = zeros(length(tLevels), 2);

    for tIdx = 1 : length(tLevels)
        t = tLevels(tIdx);
        for xIdx = 1 : length(xRange)
            [ ~, yIdx ] = min( abs( dataMatrix(:, xIdx) - t ) );
            yThresh = yRange(length(xRange) - yIdx + 1);
            xThresh = xRange(xIdx);
    
            if xIdx == 1
                t1 = [xThresh, yThresh];
            end
            if yIdx == 1
                if xIdx == 1
                    t1 = [0, 0];
                    t2 = [0, 0];
                else
                    t2 = [xThresh, yThresh];
                end
                break;
            elseif xIdx == length(xRange)
                t2 = [xThresh, yThresh];
                % break; % not needed since loop terminates here anyway
            end
        end
        tX(tIdx, :) = [t1(1), t2(1)];
        tY(tIdx, :) = [t1(2), t2(2)];
    end

    imagesc([0 5], [1 0], dataMatrix, dataRange); set(gca, 'YDir','normal');
    hold on;
    if contourLevels > 0
        contour(xRange, yRange, flip(dataMatrix), contourLevels, '-w');
    end
    Heatmap = gca;
    set(Heatmap,'XTickLabel', xTicks, 'fontsize', 6, 'FontName', FontName);
    xlabel(xLabel, FontName=FontName, FontSize=9);
    if yLabel ~= ""
        ylabel(yLabel, FontName=FontName, FontSize=9);
    end
    if plotTitle ~= ""
        title(plotTitle, FontName=FontName, FontWeight="normal", FontSize=10);
    end
    if plotSubtitle ~= ""
        text(-0.1, 1.1, plotSubtitle, FontName=FontName, FontSize=11, FontWeight="normal", Units="normalized");
    end

    pbaspect([1 1 1]);
    
    for tIdx = 1 : length(tLevels)
        if sum(tX(tIdx, :) + tY(tIdx, :)) == 0
            continue;
        end
        plot(tX(tIdx, :), tY(tIdx, :), LineWidth=1, Color=tColors{tIdx});
        label = [num2str(round(100 * thresholds(tIdx))) '%'];
        text(median(tX(tIdx, :)), median(tY(tIdx, :)), label, ...
            Color=tColors{tIdx}, FontName=FontName, fontsize=9, ...
            VerticalAlignment='top' ...
        );
    end
    hold off;
    
    if legendLabel ~= ""
        Colorbar = colorbar();
        Colorbar.Label.String = legendLabel;
        Colorbar.Label.FontName = FontName;
        Colorbar.Label.FontSize = 9;
        if width(thresholds) > 0 & false
            ColorbarOverlay = axes('position', Colorbar.Position, 'ylim', Colorbar.Limits, 'color', 'none', 'visible','off');
            for tIdx = 1 : length(tLevels)
                line(ColorbarOverlay.XLim, tLevels(tIdx)*[1 1], 'lineWidth', 1, 'color', tColors{tIdx}, 'parent', ColorbarOverlay);
            end
        end
    end
end

function MakeCombinatorialPlot(Args)
% MakeCombinatorialPlot creates a combinatorial QS plot
    arguments
        Args.C12 (:, :) double             % 2D matrix of C12 data
        Args.C4  (:, :) double             % 2D matrix of C4 data
        Args.fraction double               % percent of max to show
        Args.plotTitle string              % title of plot
        Args.plotSubtitle string = ""      % subtitle (A, B, C, ...)
        Args.xRange (:, 1) double          % range of x-axis values
        Args.yRange (:, 1) double          % range of y-axis values
        Args.xLabel string = ""            % x-axis label
        Args.yLabel string = ""            % y-axis label
        Args.legendLabel string = ""       % label for legend
        Args.xTicks = {'0', '0.5', '1', '1.5', '2'}
    end

    global FontName LasIColor RhlIColor;

    C12 = Args.C12;
    C4  = Args.C4;
    plotTitle = Args.plotTitle;
    plotSubtitle = Args.plotSubtitle;
    xRange = Args.xRange;
    yRange = Args.yRange;
    xLabel = Args.xLabel;
    yLabel = Args.yLabel;
    legendLabel = Args.legendLabel;
    fraction = Args.fraction;
    xTicks = Args.xTicks;

    C12Max = max(C12, [], "all");
    C4Max =  max(C4, [], "all");
 
    C12Matrix = contour(xRange, yRange, flip(C12), fraction * [C12Max, C12Max], LineWidth=2, Color=LasIColor);
    hold on;
    C4Matrix = contour(xRange, yRange, flip(C4), fraction * [C4Max, C4Max], LineWidth=2, Color=RhlIColor);   
    
    set(gca,'XTickLabel', xTicks, 'fontsize', 6, 'FontName', FontName);
    xlabel(xLabel, FontName=FontName, FontSize=9);
    if yLabel ~= ""
        ylabel(yLabel, FontName=FontName, FontSize=9);
    end
    if plotTitle ~= ""
        title(plotTitle, FontName=FontName, FontWeight="normal", FontSize=10);
    end
    if plotSubtitle ~= ""
        text(-0.1, 1.1, plotSubtitle, FontName=FontName, FontSize=11, FontWeight="normal", Units="normalized");
    end

    pbaspect([1 1 1]);
    
    hold off;

    C12Vector = [C12Matrix(1, end) - C12Matrix(1, 2), C12Matrix(2, end) - C12Matrix(2, 2), 0];
    C4Vector = [C4Matrix(1, end) - C4Matrix(1, 2), C4Matrix(2, end) - C4Matrix(2, 2), 0];
    Theta = round(atan2d(norm(cross(C12Vector, C4Vector)), dot(C12Vector, C4Vector)), 1);

    text(0.5, 0.25, append("\theta = ", num2str(Theta), "\circ"), ...
        Units="normalized", ...
        FontName=FontName, FontSize=7, ...
        HorizontalAlignment="center", VerticalAlignment="bottom" ...
    );
    
    if legendLabel ~= ""
        Legend = legend(["3–oxo–C_{12}–HSL", "C_{4}-HSL"], ...
            FontName=FontName, FontSize=7, ...
            Direction="reverse", Location='northeastoutside' ...
        );
        title(Legend, legendLabel, FontName=FontName, FontSize=7);
    end
end